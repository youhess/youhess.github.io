[{"content":"很可爱的歌啊 歌词：\n点样开摩托\n未见过猪行路吃主肉太多\n揸车的感觉\n如同派拖~~~啊~~~一样甘爽\n十字路口交警一个\n抓住冇带帽过个\n漫漫人生只得一趟\n冇证驾驶怕边个\n米黑摸摸我而家开始 点火\n副歌:\n喔第一次我骑摩托嘅时候\n咩黑斜斜忘记开大锁\n喔第一次我开摩托嘅时候\n刹制刹制惊人地撞飞我！\n慢慢开系啊民族大道\n单车都几快窝！\n喔第一揾人修车嘅时候\n万零公里都未换过机油\n喔第一次洗完摩托嘅时候\n路个啊婆问我要打蜡么，\n南园街晚晚公共厕所~~~停摩托！\n","date":"2025-05-19T00:00:00Z","permalink":"http://youhess.github.io/p/first-motorbike/","title":"第一次骑摩托"},{"content":"UdonSharp 同步方法指南 同步变量 1. 同步模式设置 在类定义上方添加同步模式属性：\n1 2 [UdonBehaviourSyncMode(BehaviourSyncMode.Manual)] // 手动同步 [UdonBehaviourSyncMode(BehaviourSyncMode.Continuous)] // 连续同步 2. 可同步变量标记 使用 [UdonSynced] 属性标记需要同步的变量：\n1 2 3 [UdonSynced] private int myValue; [UdonSynced] private string myText; [UdonSynced] private bool myState; 3. 复杂数据类型同步 对于复杂数据类型，需要序列化成字符串：\n1 2 [UdonSynced] private string serializedData; // 存储序列化后的JSON private DataList myDataList; // 实际使用的数据对象 同步方法 1. 请求同步 修改变量后，调用请求同步方法将数据发送给所有玩家：\n1 RequestSerialization(); 2. 监听反序列化 当接收到同步数据时，通过此方法处理：\n1 2 3 4 public override void OnDeserialization() { // 处理同步后的数据 } 3. 网络事件 向特定目标或所有玩家发送事件：\n1 2 3 4 5 // 发送给所有玩家 SendCustomNetworkEvent(NetworkEventTarget.All, \u0026#34;方法名\u0026#34;); // 发送给除自己外的所有玩家 SendCustomNetworkEvent(NetworkEventTarget.Others, \u0026#34;方法名\u0026#34;); 4. 延迟网络事件 设置延迟执行的事件：\n1 SendCustomEventDelayedSeconds(\u0026#34;方法名\u0026#34;, 延迟秒数); 所有权控制 1. 检查所有权 验证当前玩家是否拥有对象所有权：\n1 2 3 if (Networking.IsOwner(gameObject)) { // 只有拥有所有权的玩家才执行 } 2. 获取/设置所有权 1 2 3 4 5 // 获取当前所有者 VRCPlayerApi owner = Networking.GetOwner(gameObject); // 设置所有权（仅当前玩家能设置自己为所有者） Networking.SetOwner(Networking.LocalPlayer, gameObject); 3. 所有权变更监听 监听所有权转移事件：\n1 2 3 4 public override void OnOwnershipTransferred(VRCPlayerApi player) { // 处理所有权变更逻辑 } 数据同步最佳实践 所有权检查：修改同步变量前验证所有权 批量更新：一次性修改多个变量后再调用一次 RequestSerialization() 数据验证：OnDeserialization 中验证数据有效性 同步优化：使用 Manual 模式减少不必要的网络流量 错误处理：添加异常情况处理和数据恢复机制 通过这些方法，可以实现 UdonSharp 中的高效数据同步，保证多玩家环境下的一致性体验。\n我的问题 类型转换问题：序列化后 Int 可能变成 Double 没有原生整数类型：JSON 中所有数字都是浮点数\n","date":"2025-05-07T00:00:00Z","image":"http://youhess.github.io/p/udonsharo-serialization-json/cover_hu_47f2a29d56439ae3.jpg","permalink":"http://youhess.github.io/p/udonsharo-serialization-json/","title":"UdonSharp 同步方法指南"},{"content":"前言 “vrchat geoguesser china“ 接近尾声，虽然有许多bug要修改，但是看到vrchat上并没有中文版的“谁是卧底”，就想着趁现在有激情把想法写下来。当然这份文件在后续应该会有改进。实际的完成效果我也不清楚咯。哈哈哈\n游戏基础设置 玩家人数：10人上限，游戏开始后不能加入主游戏(所以一开始的时候要求玩家sgin in知道谁加入游戏） 游戏角色：普通玩家和卧底(Imposter) 等候区域：后来者在观众区观看，大屏幕直播当前对局 数据结构优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 玩家数据结构 let players = [ { playerName: \u0026#34;xxx\u0026#34;, // 玩家名称 playerId: \u0026#34;xxx\u0026#34;, // 玩家唯一ID isImposter: false, // 是否为卧底 isOut: false, // 是否被淘汰 cardContent: \u0026#34;Apple\u0026#34;, // 玩家拿到的词语 votes: 0, // 当前回合获得的票数 canVote: true // 是否有投票权(被淘汰后为false) } ] // 游戏状态数据 let gameState = { isGameActive: false, // 游戏是否激活 currentRound: 0, // 当前回合数 currentTurnPlayer: \u0026#34;\u0026#34;, // 当前回合玩家ID votingPhase: false, // 是否在投票阶段 winners: null, // 获胜方(\u0026#34;imposter\u0026#34;或\u0026#34;normal\u0026#34;) normalWord: \u0026#34;苹果\u0026#34;, // 普通玩家的词 imposterWord: \u0026#34;梨\u0026#34; // 卧底的词 } 游戏流程完善 准备阶段 房主可以设置游戏参数(卧底人数、每轮描述时间) 玩家加入游戏位置 房主点击\u0026quot;开始游戏\u0026quot; 游戏开始 系统随机分配卧底和普通玩家 系统分发卡牌(只对持有者可见) 显示首轮发言玩家(高亮效果) 游戏轮次 描述阶段：玩家按顺序描述自己拿到的词语(不能直接说出词语) 投票阶段：所有未淘汰玩家可以投票选择怀疑的卧底 结算阶段：得票最高者被淘汰(平票则无人淘汰) 胜利条件 普通玩家胜利：所有卧底被淘汰 卧底胜利：卧底数量大于或等于普通玩家数量 功能设计增强 投票系统 投票UI：圆形布局，点击玩家头像进行投票 投票确认：需确认后提交 投票显示：实时显示已投票人数(不显示投给谁) 计票：{ playerID1: votesCount1, playerID2: votesCount2, ... } 交互设计 当前回合高亮：玩家头顶光环效果 被淘汰效果：玩家模型变暗/半透明 卡牌显示：私人UI只对玩家自己可见 游戏状态显示：大屏幕显示当前游戏阶段 观战模式 观众席：可以看到游戏进行 信息限制：观众无法看到词语和卧底身份 技术实现建议 VRChat Udon脚本 使用UdonSharp编写逻辑 使用同步变量处理多人游戏状态 UI设计 世界中央大屏：游戏状态和计时器 个人UI：词语卡和投票界面 房主控制面板：游戏设置和开始按钮 性能优化 减少同步变量数量 设置合理的网络同步频率 额外创新功能 时间限制 描述阶段：每人60秒 投票阶段：30秒 ","date":"2025-04-08T00:00:00Z","image":"http://youhess.github.io/p/vr-wodi-design/cover_hu_c9f48764f9bdd1a7.jpg","permalink":"http://youhess.github.io/p/vr-wodi-design/","title":"谁是卧底 VRChat 中文版"}]