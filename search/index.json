[{"content":"UdonSharp 同步方法指南 同步变量 1. 同步模式设置 在类定义上方添加同步模式属性：\n1 2 [UdonBehaviourSyncMode(BehaviourSyncMode.Manual)] // 手动同步 [UdonBehaviourSyncMode(BehaviourSyncMode.Continuous)] // 连续同步 2. 可同步变量标记 使用 [UdonSynced] 属性标记需要同步的变量：\n1 2 3 [UdonSynced] private int myValue; [UdonSynced] private string myText; [UdonSynced] private bool myState; 3. 复杂数据类型同步 对于复杂数据类型，需要序列化成字符串：\n1 2 [UdonSynced] private string serializedData; // 存储序列化后的JSON private DataList myDataList; // 实际使用的数据对象 同步方法 1. 请求同步 修改变量后，调用请求同步方法将数据发送给所有玩家：\n1 RequestSerialization(); 2. 监听反序列化 当接收到同步数据时，通过此方法处理：\n1 2 3 4 public override void OnDeserialization() { // 处理同步后的数据 } 3. 网络事件 向特定目标或所有玩家发送事件：\n1 2 3 4 5 // 发送给所有玩家 SendCustomNetworkEvent(NetworkEventTarget.All, \u0026#34;方法名\u0026#34;); // 发送给除自己外的所有玩家 SendCustomNetworkEvent(NetworkEventTarget.Others, \u0026#34;方法名\u0026#34;); 4. 延迟网络事件 设置延迟执行的事件：\n1 SendCustomEventDelayedSeconds(\u0026#34;方法名\u0026#34;, 延迟秒数); 所有权控制 1. 检查所有权 验证当前玩家是否拥有对象所有权：\n1 2 3 if (Networking.IsOwner(gameObject)) { // 只有拥有所有权的玩家才执行 } 2. 获取/设置所有权 1 2 3 4 5 // 获取当前所有者 VRCPlayerApi owner = Networking.GetOwner(gameObject); // 设置所有权（仅当前玩家能设置自己为所有者） Networking.SetOwner(Networking.LocalPlayer, gameObject); 3. 所有权变更监听 监听所有权转移事件：\n1 2 3 4 public override void OnOwnershipTransferred(VRCPlayerApi player) { // 处理所有权变更逻辑 } 数据同步最佳实践 所有权检查：修改同步变量前验证所有权 批量更新：一次性修改多个变量后再调用一次 RequestSerialization() 数据验证：OnDeserialization 中验证数据有效性 同步优化：使用 Manual 模式减少不必要的网络流量 错误处理：添加异常情况处理和数据恢复机制 通过这些方法，可以实现 UdonSharp 中的高效数据同步，保证多玩家环境下的一致性体验。\n我的问题 类型转换问题：序列化后 Int 可能变成 Double 没有原生整数类型：JSON 中所有数字都是浮点数\n","date":"2025-05-07T00:00:00Z","image":"http://youhess.github.io/p/udonsharo-serialization-json/cover_hu_b2e0966f21274d78.jpg","permalink":"http://youhess.github.io/p/udonsharo-serialization-json/","title":"UdonSharp 同步方法指南"},{"content":"前言 “vrchat geoguesser china“ 接近尾声，虽然有许多bug要修改，但是看到vrchat上并没有中文版的“谁是卧底”，就想着趁现在有激情把想法写下来。当然这份文件在后续应该会有改进。实际的完成效果我也不清楚咯。哈哈哈\n游戏基础设置 玩家人数：10人上限，游戏开始后不能加入主游戏(所以一开始的时候要求玩家sgin in知道谁加入游戏） 游戏角色：普通玩家和卧底(Imposter) 等候区域：后来者在观众区观看，大屏幕直播当前对局 数据结构优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 玩家数据结构 let players = [ { playerName: \u0026#34;xxx\u0026#34;, // 玩家名称 playerId: \u0026#34;xxx\u0026#34;, // 玩家唯一ID isImposter: false, // 是否为卧底 isOut: false, // 是否被淘汰 cardContent: \u0026#34;Apple\u0026#34;, // 玩家拿到的词语 votes: 0, // 当前回合获得的票数 canVote: true // 是否有投票权(被淘汰后为false) } ] // 游戏状态数据 let gameState = { isGameActive: false, // 游戏是否激活 currentRound: 0, // 当前回合数 currentTurnPlayer: \u0026#34;\u0026#34;, // 当前回合玩家ID votingPhase: false, // 是否在投票阶段 winners: null, // 获胜方(\u0026#34;imposter\u0026#34;或\u0026#34;normal\u0026#34;) normalWord: \u0026#34;苹果\u0026#34;, // 普通玩家的词 imposterWord: \u0026#34;梨\u0026#34; // 卧底的词 } 游戏流程完善 准备阶段 房主可以设置游戏参数(卧底人数、每轮描述时间) 玩家加入游戏位置 房主点击\u0026quot;开始游戏\u0026quot; 游戏开始 系统随机分配卧底和普通玩家 系统分发卡牌(只对持有者可见) 显示首轮发言玩家(高亮效果) 游戏轮次 描述阶段：玩家按顺序描述自己拿到的词语(不能直接说出词语) 投票阶段：所有未淘汰玩家可以投票选择怀疑的卧底 结算阶段：得票最高者被淘汰(平票则无人淘汰) 胜利条件 普通玩家胜利：所有卧底被淘汰 卧底胜利：卧底数量大于或等于普通玩家数量 功能设计增强 投票系统 投票UI：圆形布局，点击玩家头像进行投票 投票确认：需确认后提交 投票显示：实时显示已投票人数(不显示投给谁) 计票：{ playerID1: votesCount1, playerID2: votesCount2, ... } 交互设计 当前回合高亮：玩家头顶光环效果 被淘汰效果：玩家模型变暗/半透明 卡牌显示：私人UI只对玩家自己可见 游戏状态显示：大屏幕显示当前游戏阶段 观战模式 观众席：可以看到游戏进行 信息限制：观众无法看到词语和卧底身份 技术实现建议 VRChat Udon脚本 使用UdonSharp编写逻辑 使用同步变量处理多人游戏状态 UI设计 世界中央大屏：游戏状态和计时器 个人UI：词语卡和投票界面 房主控制面板：游戏设置和开始按钮 性能优化 减少同步变量数量 设置合理的网络同步频率 额外创新功能 时间限制 描述阶段：每人60秒 投票阶段：30秒 ","date":"2025-04-08T00:00:00Z","image":"http://youhess.github.io/p/vr-wodi-design/cover_hu_13595b85c2dedd13.jpg","permalink":"http://youhess.github.io/p/vr-wodi-design/","title":"谁是卧底 VRChat 中文版"},{"content":"前言 这是我开发的一款“VRChat 地理猜图”游戏，玩家需要根据全景图像猜测其地理位置，并将自己的 Pin 拖拽到地图上。项目灵感来源于 Geoguessr，但加入了中文地图、得分系统等自定义设计。我的朋友Oikki对我的游戏开发提供了极为重要的帮助，在这里再次感谢！\n游戏机制简述 玩家操作：拖动属于自己的 Pin 到地图上进行定位\n核心流程：展示全景图 → 玩家放置位置 → 答案揭晓 → 计算得分\n胜利规则：在多轮游戏后总得分最高者胜出\n技术实现 坐标映射系统 使用 LatLongMapper 将地图 UI 坐标与实际经纬度进行双向映射\n1 2 Vector2 LatLongToUICoords(Vector2 latLong); // 经纬度 → UI坐标 Vector2 UICoordsToLatLong(Vector2 position); // UI坐标 → 经纬度 玩家 Pin 控制 每位玩家使用 Cyan.PlayerObjectPool 分配一个 Pin（GameObject）\n使用 Networking.GetOwner() 限定拾取权限\n仅本地玩家可见自己的 Pin，非 owner 设置为透明状态\n放置检测通过与 MapTable 碰撞触发逻辑判断是否在地图范围内PinController\n数据管理系统 PinDataManager 使用 UdonSynced + VRCJson 实现跨客户端同步玩家的经纬度数据\n每轮玩家猜测被存储为 DataList，每个回合自动序列化/反序列化数据PinDataManager\n最终得分通过与正确坐标的欧几里得距离计算出，采用非线性函数平滑处理分数\n地图与答案 正确答案存储在 LocationRoundData.cs 中，预先导入 json 文件\n每轮显示的全景图与答案位置通过 imageUrls[] 和 locationDataList[] 对应LocationRoundData\n得分逻辑 1 2 float distance = Vector2.Distance(correct, guess); float score = distance \u0026lt; 1f ? 95~100 : Mathf.Max(0, 95 * (1 - pow(normalized, 2))); 放置不合法（未命中地图）得分为 0\n支持对 每轮成绩 和 最终总分 进行排序展示\n多人同步与网络优化 房主负责开始游戏并推进阶段（准备 / 猜测 / 揭晓）\nOnDeserialization 中 UI 状态恢复 + 图片同步处理\nRequestSerialization + SendCustomNetworkEvent 用于状态广播与视图更新\n音效交互 不同阶段播放不同 AudioClip（按钮音、倒计时音、揭晓音）\n","date":"2025-05-27T00:00:00Z","image":"http://youhess.github.io/p/vr-geoguesser-design/GeoGuesser_hu_7ca645dd4d677b47.jpg","permalink":"http://youhess.github.io/p/vr-geoguesser-design/","title":"vrchat geoguesser china"}]